addonName = "Dynamic Light Controller"
include( "shared.lua" )

ENT.SetEnabled = ( enabled ) =>
    @__enabled = enabled == true

ENT.SetSprite = ( sprite ) =>
    @__sprite = sprite

ENT.SetRed = ( red ) =>
    @__red = red or 0

ENT.SetGreen = ( green ) =>
    @__green = green or 0

ENT.SetBlue = ( blue ) =>
    @__blue = blue or 0

ENT.SetBrightness = ( brightness ) =>
    @__brightness = brightness or 1

ENT.SetRadius = ( radius ) =>
    @__radius = radius or 256

-- https://developer.valvesoftware.com/wiki/Light_dynamic#Appearances
ENT.SetStyle = ( style ) =>
    @__style = style or 0

ENT.SetNoModel = ( nomodel ) =>
    @__nomodel = nomodel == true

ENT.SetNoWorld = ( noworld ) =>
    @__noworld = noworld == true

ENT.SetSpriteAlpha = ( alpha ) =>
    @__sprite_alpha = alpha or 255

ENT.SetSpriteScale = ( scale ) =>
    @__sprite_scale = scale or 1

:GetRed, :GetGreen, :GetBlue = ENT
ENTITY = FindMetaTable( "Entity" )
:GetPos = ENTITY

radius = 0

getCalculatedRadius, getCalculatedBrightness = nil, nil
do

    :GetEnabled, :GetRadius, :GetBrightness = ENT
    :DistToSqr = FindMetaTable( "Vector" )
    :GetLightColor = render
    :FindByClass = ents
    :IsDormant = ENTITY
    :TraceLine = util
    EyePos = EyePos
    :sort = table
    :abs = math

    getCalculatedRadius = =>
        return @__calculatedRadius or GetRadius( @ )

    getCalculatedBrightness = =>
        return @__calculatedBrightness or GetBrightness( @ )

    ENT.GetCalculatedRadius = getCalculatedRadius

    sqrCache = setmetatable( {}, { __index: ( tbl, key ) ->
        rawset( tbl, key, key * key )
        return tbl[ key ]
    } )

    cl_dlc_distance = CreateClientConVar( "cl_dlc_distance", "2048", true, false, "Maximum distance to calculate dynamic lights.", 16, 4096 )

    maxDistance = cl_dlc_distance\GetInt!
    maxDistanceSqr = sqrCache[ maxDistance ]

    cvars.AddChangeCallback( cl_dlc_distance\GetName!, ( _, __, value ) ->
        maxDistance = math.floor( tonumber( value ) or cl_dlc_distance\GetDefault! )
        maxDistanceSqr = sqrCache[ maxDistance ]
    addonName )

    cl_dlc_speed = CreateClientConVar( "cl_dlc_speed", "5", true, false, "Dynamic light update speed.", 0, 100 )

    cvars.AddChangeCallback( cl_dlc_speed\GetName!, ( _, __, value ) ->
        timer.Adjust( addonName, 1 / ( tonumber( value ) or cl_dlc_speed\GetDefault! ), 0 )
    addonName )

    sortByDistance = ( a, b ) ->
        return a[ 8 ] < b[ 8 ]

    temp, tempLength = setmetatable( {}, { __mode: "k" } ), 0
    brightness, distance = 0, 0
    dlights, length = {}, 0
    controllerCount = 0
    r, g, b = 0, 0, 0

    traceResult = {}
    trace = { collisiongroup: COLLISION_GROUP_WORLD, output: traceResult }

    timer.Create addonName, 1 / cl_dlc_speed\GetFloat!, 0, ->
        if tempLength ~= 0
            for index = 1, tempLength
                temp[ index ] = nil

            tempLength = 0

        controllers = FindByClass( "dlight_controller" )
        controllerCount = #controllers
        if controllerCount == 0
            return

        eyePos = EyePos!

        for index = 1, controllerCount
            entity = controllers[ index ]
            entity.__illuminates = false
            entity.__visible = false

            if not GetEnabled( entity ) or IsDormant( entity )
                continue

            origin = GetPos( entity )
            distance = DistToSqr( origin, eyePos )
            if distance > maxDistanceSqr
                continue

            trace.start = origin
            trace.endpos = origin
            TraceLine( trace )

            if traceResult.HitWorld
                continue

            brightness = GetBrightness( entity )
            color, r, g, b = GetLightColor( origin ) * 255, GetRed( entity ) * brightness, GetGreen( entity ) * brightness, GetBlue( entity ) * brightness
            if color[ 1 ] > ( r + 16 ) or color[ 2 ] > ( g + 16 ) or color[ 3 ] > ( b + 16 )
                continue

            tempLength += 1
            temp[ tempLength ] = { entity, origin, GetRadius( entity ), brightness, r, g, b, distance }
            entity.__visible = true

        if tempLength == 0
            return

        if tempLength == 1
            entity = temp[ 1 ][ 1 ]
            entity.__illuminates = true
            entity.__calculatedRadius = temp[ 3 ]
            entity.__calculatedBrightness = temp[ 4 ]
            return

        for index = 1, tempLength
            data = temp[ index ]
            if data == false
                continue

            radius = data[ 3 ]
            brightness = data[ 4 ]
            radiusSqr = sqrCache[ radius * 0.5 ]
            r, g, b = data[ 5 ], data[ 6 ], data[ 7 ]

            origin = data[ 2 ]
            for index2 = 1, tempLength
                if index == index2
                    continue

                data2 = temp[ index2 ]
                if data2 == false or radius < data2[ 3 ]
                    continue

                distance = DistToSqr( origin, data2[ 2 ] )
                if distance > radiusSqr
                    continue

                if abs( r - data2[ 5 ] ) < 8 and abs( g - data2[ 6 ] ) < 8 and abs( b - data2[ 7 ] ) < 8
                    temp[ index2 ] = false
                    radius += data2[ 3 ] / 2
                    brightness += data2[ 4 ] / 10

                    if distance <= ( radiusSqr * 0.25 )
                        entity = data2[ 1 ]
                        entity.__visible = false
                        entity.__calculatedRadius = radius

            if radius > maxDistance
                radius = maxDistance

            if brightness > 5
                brightness = 5

            data[ 3 ], data[ 4 ] = radius, brightness

        length = 0

        for index = 1, tempLength
            if temp[ index ] == false
                continue

            length += 1
            dlights[ length ] = temp[ index ]

        if length == 0
            return

        if length > 32
            sort( dlights, sortByDistance )
            length = 32

        for index = 1, length
            data = dlights[ index ]

            entity = data[ 1 ]
            entity.__illuminates = true
            entity.__calculatedRadius = data[ 3 ]
            entity.__calculatedBrightness = data[ 4 ]

getIndex = nil
do

    clientIndexes = {}

    hook.Add "EntityRemoved", addonName, ( entity ) ->
        index = entity.DLightIndex
        if not index or clientIndexes[ index ] ~= entity
            return

        clientIndexes[ index ] = nil

    :EntIndex, :GetParent = ENTITY
    index = 0

    getIndex = ( entity ) ->
        index = entity.DLightIndex or EntIndex( entity )
        if index == -1
            parent = GetParent( entity )
            if parent\IsValid!
                index = EntIndex( parent )

            if index == -1
                index = 8192
                ::findIndex::

                otherEntity = clientIndexes[ index ]
                if otherEntity and otherEntity\IsValid! and otherEntity ~= entity
                    index += 1
                    goto findIndex

                clientIndexes[ index ] = entity
                entity.DLightIndex = index

        return index

    ENT.GetIndex = getIndex

:GetSprite = ENT

do

    :GetStyle, :GetNoModel, :GetNoWorld, :IsDeathTime = ENT
    DynamicLight = DynamicLight
    :SetRenderBounds = ENTITY
    CurTime = CurTime
    Vector = Vector

    ENT.Think = =>
        if IsDeathTime( @ )
            @Remove!
            return

        @LightThink!

        unless @__illuminates
            return

        dlight = DynamicLight( getIndex( @ ) )
        unless dlight
            return

        -- Static stuff
        dlight.dietime = CurTime! + 1
        dlight.decay = 1000

        -- Dynamic stuff
        dlight.r, dlight.g, dlight.b = GetRed( @ ), GetGreen( @ ), GetBlue( @ )
        dlight.nomodel, dlight.noworld = GetNoModel( @ ), GetNoWorld( @ )
        dlight.brightness = getCalculatedBrightness( @ )
        dlight.size = getCalculatedRadius( @ )
        dlight.style = GetStyle( @ )
        dlight.pos = GetPos( @ )

        if GetSprite( @ ) == ""
            return

        radius = getCalculatedRadius( @ )
        SetRenderBounds( @, Vector( -radius, -radius, -radius ), Vector( radius, radius, radius ) )

do

    materialCache, color = {}, Color( 0, 0, 0 )
    :GetSpriteAlpha, :GetSpriteScale = ENT
    :DrawSprite, :SetMaterial = render

    ENT.Draw = =>
        if @__visible
            materialPath = GetSprite( @ )
            if materialPath == ""
                return

            unless materialCache[ materialPath ]
                materialCache[ materialPath ] = Material( materialPath )

            SetMaterial( materialCache[ materialPath ] )

            color.r, color.g, color.b, color.a = GetRed( @ ), GetGreen( @ ), GetBlue( @ ), GetSpriteAlpha( @ )
            radius = getCalculatedRadius( @ ) * GetSpriteScale( @ )

            DrawSprite( GetPos( @ ), radius, radius, color )

ENT.LightThink = ->
